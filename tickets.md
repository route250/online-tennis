# 詳細チケット: 対戦型テニスゲーム（サーバ中心設計）

各チケットは「目的 / 成果物 / 実装ステップ / 受け入れ基準 / 見積り / 依存関係」を含む。

---

## 1. プロジェクト初期化（再確認）
- 目的: サーバ中心に作業するためにディレクトリ構成と基本ファイルを整理する。
- 成果物:
  - server/ ディレクトリ（サーバコード）
  - package.json（dev スクリプトに server 起動コマンドを追加）
  - README.md 更新（サーバ起動手順）
- 実装ステップ:
  1. server/ ディレクトリ作成
  2. package.json に "server": "node server/index.js" を追加
  3. README にサーバ起動手順を追記
- 受け入れ基準:
  - `npm run server` でサーバが起動する（依存インストールが必要な旨を README に記載）
- 見積り: 0.5日
- 依存関係: なし

---

## 2. サーバ最小実装（Express + ws）
- 目的: WebSocket ベースの中心サーバを立ち上げ、静的配信と /ws を提供する。
- 成果物:
  - server/index.js（Express サーバ + ws WebSocket サーバ）
  - サーバ起動スクリプト（package.json）
- 実装ステップ:
  1. Express を使って静的ファイル配信（client 用ビルドまたはルート）
  2. ws で /ws 接続ハンドラを作成
  3. CONNECT / CONNECT_ACK の基本ハンドシェイクを実装
  4. 接続ユーザリスト保持（id, name, ws, lastSeen）
- 受け入れ基準:
  - ブラウザが ws://.../ws に接続して CONNECT_ACK を受け取る
- 見積り: 1日
- 依存関係: プロジェクト初期化

---

## 3. メッセージ仕様詳細化（JSON スキーマ）
- 目的: サーバ・クライアント間で交換するメッセージの正式仕様を作る。
- 成果物:
  - docs/protocol.md（各メッセージのフィールド・例・必須/任意を記載）
- 実装ステップ:
  1. 既存の spec.md を基にメッセージ型ごとの JSON スキーマと例を記載
  2. 必須フィールド（type, senderId, ts, payload）を明示
- 受け入れ基準:
  - サーバ・クライアント共に protocol.md を参照して実装できる
- 見積り: 0.5日
- 依存関係: サーバ最小実装

---

## 4. ロビー管理（PARTICIPANTS 配信・HEARTBEAT）
- 目的: 接続クライアントの一覧をサーバが管理し、全クライアントに配信する。
- 成果物:
  - サーバ側 PARTICIPANTS ブロードキャスト（接続/切断/heartbeat により更新）
  - クライアント側で PARTICIPANTS を受け取り UI を更新する処理（src/app.js 修正）
- 実装ステップ:
  1. サーバで heartbeat タイムアウト判定と participants 配信ロジックを実装（5s heartbeat 推奨）
  2. クライアントで CONNECT → JOIN_LOBBY を送信、PARTICIPANTS を受信して participantsList を更新
- 受け入れ基準:
  - 複数クライアントが接続すると各クライアントの参加者リストに反映される
- 見積り: 1日
- 依存関係: サーバ最小実装, メッセージ仕様

---

## 5. マッチメイキング（INVITE / INVITE_RESPONSE / ROOM 管理）
- 目的: 対戦申し込み・承諾のフローをサーバ経由で実現する。
- 成果物:
  - INVITE の転送、INVITE_RESPONSE の処理、ROOM 作成ロジック
  - ROOM_CREATED メッセージで双方にルームIDとロール（player1/player2）を通知
- 実装ステップ:
  1. サーバで INVITE 受信時に target に転送
  2. 相手の応答を待ち、承諾ならルームを生成して通知
  3. ルーム内の簡易状態（players, status）を管理
- 受け入れ基準:
  - 申し込み→承諾で両者に ROOM_CREATED が届く
- 見積り: 1日
- 依存関係: ロビー管理

---

## 6. ゲームシミュレーション（サーバ権威）
- 目的: サーバが authoritative に物理計算を行い、定期的に GAME_STATE を配信する。
- 成果物:
  - サーバ側のゲームループ（例 20Hz）で物理（ボール位置/速度、得点）を更新
  - GAME_STATE メッセージの送信実装
- 実装ステップ:
  1. ルーム作成時にゲームループを開始（または START_GAME トリガ）
  2. 入力（INPUT）を受け取り反映（パドル位置更新、サーブ待ち中はボール追随）
  3. 各 tick 毎に GAME_STATE を全プレイヤに送信（scores/serveId 含む）
- 受け入れ基準:
  - サーバから定期的に GAME_STATE が届き、サーバ側で状態が進行する
- 見積り: 2日
- 依存関係: マッチメイキング

---

## 7. クライアント改修（WebSocket 対応・INPUT 送信・補間表示）
- 目的: 既存のクライアントコードを WebSocket ベースでサーバに接続し、GAME_STATE を受取り補間して描画する。
- 成果物:
  - src/app.js の WebSocket 実装（CONNECT/JOIN_LOBBY/HEARTBEAT/INPUT 送信、PARTICIPANTS/GAME_STATE 受信処理）
  - 受信した GAME_STATE を補間して滑らかに描画するロジック
- 実装ステップ:
  1. WebSocket 接続処理を追加
  2. ロビー UI の参加者リスト更新を PARTICIPANTS に同期
  3. 対戦申し込みボタンで INVITE をサーバに送る
  4. ゲーム画面で入力（マウスドラッグ）を INPUT メッセージで送信
  5. GAME_STATE を受け取り描画（自分視点ミラー、スコアはDOMパネル）
- 受け入れ基準:
  - クライアントがサーバに接続して PARTICIPANTS を受信できる
  - GAME_STATE を受け取り視覚的にゲームが進行する
- 見積り: 2日
- 依存関係: サーバ側 GAME_STATE 実装

---

## 8. テスト（結合・マルチクライアント）
- 目的: 2端末以上での接続・マッチング・ゲーム同期を検証する。
- 成果物:
  - 手順書（テストケース）、実行ログ
- 実装ステップ:
  1. ローカル環境でサーバ起動
  2. 別タブ/別端末で複数クライアントを接続して動作確認
  3. 遅延・切断をシミュレートして挙動を確認
- 受け入れ基準:
  - 主要シナリオが成功する（接続→招待→承諾→ルーム作成→GAME_STATE 受信）
- 見積り: 1日
- 依存関係: 全機能

---

## 9. ドキュメントとデプロイ準備
- 目的: 開発者向けのセットアップ手順と仕様を整備する。
- 成果物:
  - README.md 更新（サーバ起動・テスト手順）
  - docs/protocol.md（メッセージ仕様）
- 実装ステップ:
  1. 実装に合わせて README を更新
  2. protocol.md を整備
- 受け入れ基準:
  - 新しい開発者が手順に従って環境を構築できる
- 見積り: 0.5日
- 依存関係: 実装完了機能

---

必要なら、上記チケットをさらにコミット単位（PR 向け）に細分化します。

---

## 変更履歴（実装済みの主な項目）
- サーバ権威の物理（20Hz）、スイープ判定によるすり抜け対策
- 返球・サーブ時にパドル速度を反映（角度・速度調整、速度上限）
- 得点後は停止し、得点者が次サーブ（serveId配信）。サーブ前はボールがパドルに追随
- 画面ミラー（招待側は自分が常に下）
- スコアボードをDOMで右側に分離（プレイ領域に非干渉）
- フィールド 500x700、パドル幅 80、黒基調UI＋コートライン装飾
